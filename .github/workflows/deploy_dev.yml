name: Deploy to Development

on:
  push:
    branches: [dev]
  workflow_dispatch:

env:
  APP_NAME: brainforest-api-dev
  DEPLOY_PATH: ~/brainforest-api-dev

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies and build
        run: |
          bun install --frozen-lockfile
          bun run build
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to server
        run: |
          # Create deployment directory
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}"
          # Sync files (exclude unnecessary files)
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.env*' \
            --exclude='*.log' \
            ./ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ env.DEPLOY_PATH }}/
      - name: System health check
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üîç System Health Check"

            # Check disk space
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 90 ]; then
              echo "‚ö†Ô∏è  WARNING: Disk usage is at ${DISK_USAGE}%"
            else
              echo "‚úÖ Disk usage: ${DISK_USAGE}%"
            fi

            # Check memory usage
            MEM_USAGE=$(free | awk 'NR==2 {printf "%.0f", $3*100/$2}')
            echo "üìä Memory usage: ${MEM_USAGE}%"

            # Check if nginx is installed
            if command -v nginx &> /dev/null; then
              echo "‚úÖ Nginx is installed"
            else
              echo "‚ö†Ô∏è  Nginx is not installed"
            fi
          EOF

      - name: Install and restart application
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          PORT: ${{ secrets.PORT }}
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Set environment variables for this session
            export NODE_ENV=development
            export DATABASE_URL="${{ secrets.DATABASE_URL }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export PORT="${{ secrets.PORT }}"

            echo "üì¶ Installing production dependencies..."
            bun install --production --frozen-lockfile

            # Run migrations with error handling
            echo "üîÑ Running database migrations..."
            if ! bun run migrate; then
              echo "‚ö†Ô∏è  Migration failed, but continuing deployment..."
            fi

            # Install PM2 if not already installed
            if ! command -v pm2 &> /dev/null; then
              echo "üì¶ Installing PM2..."
              npm install -g pm2
            fi

            # Setup PM2 startup script
            echo "‚öôÔ∏è  Configuring PM2 startup..."
            PM2_STARTUP_CMD=$(pm2 startup systemd -u $USER --hp $HOME | tail -n 1)
            if [[ "$PM2_STARTUP_CMD" == sudo* ]]; then
              echo "Running: $PM2_STARTUP_CMD"
              eval "$PM2_STARTUP_CMD" || echo "‚ö†Ô∏è  PM2 startup configuration may require manual sudo"
            fi

            # Stop old PM2 process
            pm2 delete ${{ env.APP_NAME }} 2>/dev/null || true

            # Create PM2 ecosystem config for advanced restart policies
            echo "üìù Creating PM2 ecosystem configuration..."
            cat > ecosystem.config.js <<'ECOSYSTEM_EOF'
            module.exports = {
              apps: [{
                name: "${{ env.APP_NAME }}",
                script: "bun",
                args: "dist/index.js",
                cwd: "${{ env.DEPLOY_PATH }}",
                env: {
                  NODE_ENV: "development",
                  PORT: "${{ secrets.PORT }}",
                  HOST: "0.0.0.0",
                  DATABASE_URL: "${{ secrets.DATABASE_URL }}",
                  JWT_SECRET: "${{ secrets.JWT_SECRET }}"
                },
                max_restarts: 10,
                min_uptime: "10s",
                restart_delay: 3000,
                autorestart: true,
                watch: false
              }]
            };
            ECOSYSTEM_EOF

            # Start the application with ecosystem config
            echo "üöÄ Starting application..."
            pm2 start ecosystem.config.js

            # Save PM2 process list for resurrection
            pm2 save

            # Configure PM2 log rotation (after save)
            echo "‚öôÔ∏è  Configuring PM2 log rotation..."
            pm2 install pm2-logrotate || echo "‚ö†Ô∏è  PM2 logrotate install failed, skipping..."
            pm2 set pm2-logrotate:max_size 10M || true
            pm2 set pm2-logrotate:retain 7 || true
            pm2 save

            echo "‚úÖ Application started"
          EOF

      - name: Configure and verify nginx
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üîß Configuring Nginx..."

            # Install nginx if not present
            if ! command -v nginx &> /dev/null; then
              echo "üì¶ Installing Nginx..."
              sudo apt-get update
              sudo apt-get install -y nginx
            fi

            # Test nginx configuration
            echo "üß™ Testing Nginx configuration..."
            if sudo nginx -t; then
              echo "‚úÖ Nginx configuration is valid"

              # Enable nginx to start on boot
              sudo systemctl enable nginx

              # Restart nginx
              echo "üîÑ Restarting Nginx..."
              sudo systemctl restart nginx

              # Verify nginx is running
              if sudo systemctl is-active --quiet nginx; then
                echo "‚úÖ Nginx is running"
              else
                echo "‚ùå Nginx failed to start"
                sudo systemctl status nginx
              fi

              # Check if nginx is listening on ports
              echo "üîç Checking Nginx ports..."
              if sudo netstat -tlnp | grep -q ':80.*nginx'; then
                echo "‚úÖ Nginx listening on port 80"
              else
                echo "‚ö†Ô∏è  Nginx not listening on port 80"
              fi

              if sudo netstat -tlnp | grep -q ':443.*nginx'; then
                echo "‚úÖ Nginx listening on port 443"
              else
                echo "‚ö†Ô∏è  Nginx not listening on port 443"
              fi
            else
              echo "‚ùå Nginx configuration test failed"
              echo "‚ö†Ô∏è  Continuing deployment, but nginx may not be working correctly"
            fi
          EOF

      - name: Health checks with retries
        env:
          PORT: ${{ secrets.PORT }}
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üè• Running health checks..."

            # Wait for app to start
            echo "‚è≥ Waiting for application to start (10s)..."
            sleep 10

            # Check PM2 process status
            echo "üîç Checking PM2 process status..."
            if pm2 list | grep -q "${{ env.APP_NAME }}.*online"; then
              echo "‚úÖ PM2 process is online"
              pm2 show ${{ env.APP_NAME }}
            else
              echo "‚ùå PM2 process is not online"
              pm2 logs ${{ env.APP_NAME }} --lines 20
              exit 1
            fi

            # Check if application is listening on port
            echo "üîç Checking if application is listening on port ${{ secrets.PORT }}..."
            if netstat -tlnp 2>/dev/null | grep -q ":${{ secrets.PORT }}"; then
              echo "‚úÖ Application is listening on port ${{ secrets.PORT }}"
            else
              echo "‚ö†Ô∏è  No process listening on port ${{ secrets.PORT }}"
            fi

            # Test HTTP endpoint with retries
            echo "üîç Testing HTTP endpoint (3 attempts)..."
            SUCCESS=false
            for i in {1..3}; do
              echo "Attempt $i/3..."
              if curl -sf http://localhost:${{ secrets.PORT }}/health > /dev/null 2>&1 || \
                 curl -sf http://localhost:${{ secrets.PORT }} > /dev/null 2>&1; then
                echo "‚úÖ HTTP endpoint responding"
                SUCCESS=true
                break
              fi
              if [ $i -lt 3 ]; then
                echo "‚è≥ Retrying in 2 seconds..."
                sleep 2
              fi
            done

            if [ "$SUCCESS" = false ]; then
              echo "‚ö†Ô∏è  HTTP endpoint not responding after 3 attempts"
            fi

            echo "‚úÖ Health checks complete"
          EOF

      - name: Cleanup old logs
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üßπ Cleaning up old logs..."
            cd ${{ env.DEPLOY_PATH }}

            # Remove logs older than 7 days
            find . -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true

            echo "‚úÖ Cleanup complete"
          EOF

      - name: Deployment summary
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo ""
            echo "========================================="
            echo "üéâ DEPLOYMENT SUMMARY"
            echo "========================================="
            echo "Application: ${{ env.APP_NAME }}"
            echo "Environment: development"
            echo "PM2 Status:"
            pm2 list
            echo ""
            echo "Recent PM2 Logs:"
            pm2 logs ${{ env.APP_NAME }} --lines 5 --nostream
            echo "========================================="
            echo "‚úÖ Development deployment successful!"
          EOF