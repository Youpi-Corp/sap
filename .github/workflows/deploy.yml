name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  APP_NAME: brainforest-api
  DEPLOY_PATH: ~/brainforest-api

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies and build
        run: |
          bun install --frozen-lockfile
          bun run build

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to server
        run: |
          # Create deployment directory
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}"          # Sync files (exclude unnecessary files)
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.env*' \
            --exclude='*.log' \
            ./ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ env.DEPLOY_PATH }}/

      - name: System health check
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üîç System Health Check"

            # Check disk space
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 90 ]; then
              echo "‚ö†Ô∏è  WARNING: Disk usage is at ${DISK_USAGE}%"
            else
              echo "‚úÖ Disk usage: ${DISK_USAGE}%"
            fi

            # Check memory usage
            MEM_USAGE=$(free | awk 'NR==2 {printf "%.0f", $3*100/$2}')
            echo "üìä Memory usage: ${MEM_USAGE}%"

            # Check if nginx is installed
            if command -v nginx &> /dev/null; then
              echo "‚úÖ Nginx is installed"
            else
              echo "‚ö†Ô∏è  Nginx is not installed"
            fi
          EOF

      - name: Install and restart application
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          PORT: ${{ secrets.PORT }}
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Set environment variables for this session
            export NODE_ENV=production
            export DATABASE_URL="${{ secrets.DATABASE_URL }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export PORT="${{ secrets.PORT }}"

            echo "üì¶ Installing production dependencies..."
            bun install --production --frozen-lockfile

            # Run migrations with error handling
            echo "üîÑ Running database migrations..."
            if ! bun run migrate; then
              echo "‚ö†Ô∏è  Migration failed, but continuing deployment..."
            fi

            # Install PM2 if not already installed
            if ! command -v pm2 &> /dev/null; then
              echo "üì¶ Installing PM2..."
              npm install -g pm2
            fi

            # Setup PM2 startup script
            echo "‚öôÔ∏è  Configuring PM2 startup..."
            PM2_STARTUP_CMD=$(pm2 startup systemd -u $USER --hp $HOME | tail -n 1)
            if [[ "$PM2_STARTUP_CMD" == sudo* ]]; then
              echo "Running: $PM2_STARTUP_CMD"
              eval "$PM2_STARTUP_CMD" || echo "‚ö†Ô∏è  PM2 startup configuration may require manual sudo"
            fi

            # Stop old PM2 process
            pm2 delete ${{ env.APP_NAME }} 2>/dev/null || true

            # Create PM2 ecosystem config for advanced restart policies
            echo "üìù Creating PM2 ecosystem configuration..."
            echo 'module.exports = {' > ecosystem.config.cjs
            echo '  apps: [{' >> ecosystem.config.cjs
            echo '    name: "${{ env.APP_NAME }}",' >> ecosystem.config.cjs
            echo '    script: "bun",' >> ecosystem.config.cjs
            echo '    args: "dist/index.js",' >> ecosystem.config.cjs
            echo '    cwd: "${{ env.DEPLOY_PATH }}",' >> ecosystem.config.cjs
            echo '    env: {' >> ecosystem.config.cjs
            echo '      NODE_ENV: "production",' >> ecosystem.config.cjs
            echo '      PORT: "${{ secrets.PORT }}",' >> ecosystem.config.cjs
            echo '      HOST: "0.0.0.0",' >> ecosystem.config.cjs
            echo '      DATABASE_URL: "${{ secrets.DATABASE_URL }}",' >> ecosystem.config.cjs
            echo '      JWT_SECRET: "${{ secrets.JWT_SECRET }}"' >> ecosystem.config.cjs
            echo '    },' >> ecosystem.config.cjs
            echo '    max_restarts: 10,' >> ecosystem.config.cjs
            echo '    min_uptime: "10s",' >> ecosystem.config.cjs
            echo '    restart_delay: 3000,' >> ecosystem.config.cjs
            echo '    autorestart: true,' >> ecosystem.config.cjs
            echo '    watch: false' >> ecosystem.config.cjs
            echo '  }]' >> ecosystem.config.cjs
            echo '};' >> ecosystem.config.cjs

            # Start the application with ecosystem config
            echo "üöÄ Starting application..."
            pm2 start ecosystem.config.cjs

            # Save PM2 process list for resurrection
            pm2 save

            # Configure PM2 log rotation (after save)
            echo "‚öôÔ∏è  Configuring PM2 log rotation..."
            pm2 install pm2-logrotate || echo "‚ö†Ô∏è  PM2 logrotate install failed, skipping..."
            pm2 set pm2-logrotate:max_size 10M || true
            pm2 set pm2-logrotate:retain 7 || true
            pm2 save

            echo "‚úÖ Application started"
          EOF

      - name: Configure and verify nginx
        env:
          PORT: ${{ secrets.PORT }}
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üîß Configuring Nginx..."

            # Install nginx if not present
            if ! command -v nginx &> /dev/null; then
              echo "üì¶ Installing Nginx..."
              sudo apt-get update
              sudo apt-get install -y nginx
            fi

            # Create nginx site configuration if missing
            if [ ! -f /etc/nginx/sites-enabled/brainforest.conf ]; then
              echo "üìù Creating nginx site configuration for production..."
              echo 'server {' | sudo tee /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '    listen 80;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '    server_name brainforest.youpi.ovh;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '    location / {' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo "        proxy_pass http://localhost:${{ secrets.PORT }};" | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_http_version 1.1;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_set_header Upgrade $http_upgrade;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo "        proxy_set_header Connection 'upgrade';" | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_set_header Host $host;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_set_header X-Real-IP $remote_addr;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_set_header X-Forwarded-Proto $scheme;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '        proxy_cache_bypass $http_upgrade;' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '    }' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              echo '}' | sudo tee -a /etc/nginx/sites-available/brainforest.conf > /dev/null
              sudo ln -sf /etc/nginx/sites-available/brainforest.conf /etc/nginx/sites-enabled/brainforest.conf
              echo "‚úÖ Created nginx configuration"
            fi

            # Test nginx configuration
            echo "üß™ Testing Nginx configuration..."
            if sudo nginx -t 2>&1; then
              echo "‚úÖ Nginx configuration is valid"

              # Enable nginx to start on boot
              sudo systemctl enable nginx

              # Restart nginx
              echo "üîÑ Restarting Nginx..."
              sudo systemctl restart nginx

              # Verify nginx is running
              if sudo systemctl is-active --quiet nginx; then
                echo "‚úÖ Nginx is running"
              else
                echo "‚ùå Nginx failed to start"
                sudo systemctl status nginx || true
              fi

              # Check if nginx is listening on ports
              echo "üîç Checking Nginx ports..."
              if sudo netstat -tlnp 2>/dev/null | grep -q ':80.*nginx'; then
                echo "‚úÖ Nginx listening on port 80"
              else
                echo "‚ö†Ô∏è  Nginx not listening on port 80"
              fi

              if sudo netstat -tlnp 2>/dev/null | grep -q ':443.*nginx'; then
                echo "‚úÖ Nginx listening on port 443"
              else
                echo "‚ö†Ô∏è  Nginx not listening on port 443 (SSL not configured)"
              fi
            else
              echo "‚ùå Nginx configuration test failed"
              echo "‚ö†Ô∏è  Continuing deployment without nginx restart"
            fi
          EOF

      - name: Health checks with retries
        env:
          PORT: ${{ secrets.PORT }}
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üè• Running health checks..."

            # Wait for app to start
            echo "‚è≥ Waiting for application to start (10s)..."
            sleep 10

            # Check PM2 process status
            echo "üîç Checking PM2 process status..."
            if pm2 list | grep -q "${{ env.APP_NAME }}.*online"; then
              echo "‚úÖ PM2 process is online"
              pm2 show ${{ env.APP_NAME }}
            else
              echo "‚ùå PM2 process is not online"
              pm2 logs ${{ env.APP_NAME }} --lines 20
              exit 1
            fi

            # Check if application is listening on port
            echo "üîç Checking if application is listening on port ${{ secrets.PORT }}..."
            if netstat -tlnp 2>/dev/null | grep -q ":${{ secrets.PORT }}"; then
              echo "‚úÖ Application is listening on port ${{ secrets.PORT }}"
            else
              echo "‚ö†Ô∏è  No process listening on port ${{ secrets.PORT }}"
            fi

            # Test HTTP endpoint with retries
            echo "üîç Testing HTTP endpoint (3 attempts)..."
            SUCCESS=false
            for i in {1..3}; do
              echo "Attempt $i/3..."
              if curl -sf http://localhost:${{ secrets.PORT }}/health > /dev/null 2>&1 || \
                 curl -sf http://localhost:${{ secrets.PORT }} > /dev/null 2>&1; then
                echo "‚úÖ HTTP endpoint responding"
                SUCCESS=true
                break
              fi
              if [ $i -lt 3 ]; then
                echo "‚è≥ Retrying in 2 seconds..."
                sleep 2
              fi
            done

            if [ "$SUCCESS" = false ]; then
              echo "‚ö†Ô∏è  HTTP endpoint not responding after 3 attempts"
            fi

            # Check SSL certificate validity (if applicable)
            if [ -f /etc/letsencrypt/live/*/cert.pem ]; then
              echo "üîç Checking SSL certificate..."
              CERT_PATH=$(sudo find /etc/letsencrypt/live -name cert.pem | head -1)
              if [ -n "$CERT_PATH" ]; then
                EXPIRY=$(sudo openssl x509 -enddate -noout -in "$CERT_PATH" | cut -d= -f2)
                echo "üìÖ SSL certificate expires: $EXPIRY"
              fi
            fi

            echo "‚úÖ Health checks complete"
          EOF

      - name: Cleanup old logs
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo "üßπ Cleaning up old logs..."
            cd ${{ env.DEPLOY_PATH }}

            # Remove logs older than 7 days
            find . -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true

            echo "‚úÖ Cleanup complete"
          EOF

      - name: Deployment summary
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            echo ""
            echo "========================================="
            echo "üéâ DEPLOYMENT SUMMARY"
            echo "========================================="
            echo "Application: ${{ env.APP_NAME }}"
            echo "Environment: production"
            echo "PM2 Status:"
            pm2 list
            echo ""
            echo "Recent PM2 Logs:"
            pm2 logs ${{ env.APP_NAME }} --lines 5 --nostream
            echo "========================================="
            echo "‚úÖ Deployment successful!"
          EOF
